\section{Efficient Evaluation of Skyline Queries in Wireless Data Broadcast Environments}

In chapter~2, we presented a broadcast data stream allocation technique (TDI) that utilizes the R-Tree and performs a depth-first traversal of the index to create a distributed index. The goals of TDI are to facilitate query processing from broadcast data, to reduce the index overhead (IP) and to improve the initial index probe. TDI is able to achieve all these with reasonable efficiency. TDI is a flexible R-tree based index and supports skyline queries as well as other data query types. The allocation distributes $b^h$ number of index segments among the broadcast program to reduce the initial index, and at the same time keeps the index overhead low. The simulation results for index percentage show that TDI performs very well with two levels of replication and follow the efficiency of one-time index with only a $16\%$ increase in index overhead.

In addition, we introduced record-based pruning skyline (RPS) and index-based pruning skyline (IPS) algorithms. The experiments show that both algorithms are capable of evaluating skyline queries of combined $min$ and $max$ attributes with reasonable tuning time and dominance tests. The index-based skyline has always performed better than the point-based skyline, in some cases by several factors. The performance of the algorithms is also affected by the data arrangement and R-Tree implementation. From our simulation, we find that R-trees that index records with lower attributes first perform better for $min$ skyline queries, and vice versa.

The simulation results show that the approach also performs well with data of higher dimensions. The index overhead decreases as the number of records remain constant and the number of data dimensions increase. This is due to the fact that the growth of dimensionality does not make the index tree grow ``taller" and does not incur the cost of new nodes when the index grows. The height of an index tree does increase as the number of records increase, but as seen in Figure~\ref{fig:ip_rc}, the growth of the index is not as fast as the growth of the amount of data; therefore, the index overhead decreases as records increase.

For the future work, we would like to expand our study of the broadcast aspect of this work. We have done preliminary design of the broadcast data serialization technique and performed analysis and experiments using simulations; in order to have an in-depth study of this aspect, experiments with physical wireless devices must be conducted.

In addition, an open issue of our skyline algorithm is how to convert a text-based attribute into an numeric value that can be indexed an used by our algorithm. An simple answer is to use hash function, however, we must consider the natural order of text strings and the mean of a string is greater than or less than the other.

\section{Hierarchical Data in Relational Database Management Systems}

In chapter~3 we conducted performance evaluation of three implementations of hierarchy in MySQL relational database. The first is the Adjacency List Model, which is realized by storing all nodes of the hierarchy in a single Nodes table, and each node, represented by a record in the table, contains a self-referencing foreign key that references the parent node.

The second is the Nested Sets Model, which is an attempt to improve the performance of data retrieving operations over the Adjacency List Model. This model is an extension of the first in that each node (or record) contain two additional {\em left} and {\em right} fields that defines the subset relationship. Left and right fields are then indexed using B-Tree for fast access. With this extension, one can easily check if a node is in the hierarchy of another node.

The third implementation is the Stored Adjacency List, in which the same algorithm used in Adjacency List Model implemented in MySQL Stored Procedure. This technique is used to verify if stored procedure is a viable way for performance tuning for hierarchy operations.

Performance evaluation were conducted using the operations defined in Section~\ref{sec_tree_ops}. Operations are divided into three performance groups: O(log N), O(N), and O(1). Members of the same group have similar performance characteristic; therefore, one operation from O(log N), and O(N) is chosen for performance evaluation as representative for the group. The evaluation for group O(1) was conducted, but not reported in this chapter, because the run time is negligible and not influenced by input size. The operation to find the root of a node was chosen to represent O(log N) group, and the operation to find all leaf nodes of a node was chosen to represent O(N) group. The performance of the models are measured in running time of the operations, in which the lower the running time the better.

For group O(log N), the evaluation reported in Section~\ref{eval_group1} shows the expected running time performance. For the Adjacency List Model, the growth rate of the algorithm is linear with respect to the height and constant with respect to the width (order) of the hierarchy. The Nested Sets Model is a huge improvement over the first in this evaluation. Based on the evaluation, the running time growth rate is constant for both dimensions. For the stored implementation, the running time is better than both other approaches. However, the project model is slow-growing linear with respect to height, and constant with respect to order.

In Group O(N), the Nested Sets Model still significantly outperformed Adjacency List Model; however the running time of the stored approach is unreasonable high for very small data sets. For the Adjacency List Model, the running time, as expected, have exponential running time growth with respect to the height of the tree. From the evaluation result, the growth rate with respect to width also appears to be exponential; however, our validation does not fit the exponential model, therefore we believe the growth is a steep linear model.

For the Nested Sets model, the growth rate is also exponential. Although the running times are much lower than that of the other approach, the growth is faster. Frankly, we did not expect an exponential growth rate due to the optimizations that has been done. We believe this could be caused by our implementation. As for the time complexity against the width, it is also exponential. This is also unexpected. Again this is due to that the implementation requires table joins, which degrades the performance very quickly as the data size increases.

An open issue and future work of our index technique is updating an hierarchy structure. A scheme must be developed so that the left and right values are assigned in the way that inserting or removing a node from the hierarchy is efficient and does not cause reassignment of the left and right values of all the nodes in the hierarchy. A possible approach is allocate the left and right values in the way that it leaves enough space for future records to be inserted.

\section{Geo-Store: A Spatially-Aware SPARQL Evaluation Engine}
\input{geo-store-journal/conc}